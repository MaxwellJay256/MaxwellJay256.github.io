[{"content":"2025.5.3 - 5.4 和同学去了 dizzylab 举办的第 2 届同人音乐主题展会 DizzyMart02。\n展会设置了社团摊位销售作品，以及舞台供演出。\n我认识的社团和人都很少，逛展并非为了社交（虽然看到网友们晒出的几十张专辑战利品和签名纸也很羡慕），能发现一些印象深刻的音乐作品足矣。\n倒不如说，避开 “粉丝” 的身份，以单纯的欣赏者来参与展会，实际体验会好很多。 听到好歌就一起打 Call，有劲爆的 DJ set 就跟着跳舞，在两天十几个小时的时间里也不会感觉无聊。\n我参加过的展子和演出不多，DizzyMart 给我的感觉是，对人群筛选严格的活动，体验会更纯净，对没有社交需求的游客也更友好。 DM 自带 “艺人 → 听众” 的内容输出关系，所以保证了游客能获得最低程度的体验：听音乐，社牛可以放肆地应援，社恐也可以安静地坐着看表演。 这次 DM 游客数量中等，虽然显得不怎么热闹，但随便朝一个方向看，并不会觉得自己违和或无事可做。 大家来都是为了见喜欢的艺人、支持好听的音乐，无他。 没有人玩烂梗整烂活更是谢天谢地。\n陪同学聊音乐和人生、在试听角体验碟机、和日本曲师短暂地互动、舞台下接住踊音老师送的无料…… 这些并非惊天动地的大事件，他们虽然无法与我日日相见，但这些微小而有意义的联系，也许正是我二十岁以来需要的，或者说一直在寻找的东西。\n这些直到展会结束我才反应过来。\n人无法被任何标签分类，却总是以各种原因聚在一起。 让我们用签绘墙上的一句话来结束这篇 repo 吧：\n","date":"2025-05-05T10:40:00+08:00","image":"https://keinestudio.cn/posts/dizzymart02-repo/images/P1030855_hu_3cd799b1185dbb9f.JPG","permalink":"https://keinestudio.cn/posts/dizzymart02-repo/","title":"微小而有意义的联系"},{"content":"2024 年年底那段时间遇到了需要自己画 PCB 的 STM32 开发需求，但手头还没有任何适合 STM32 MCU 的调试工具。 我在 DAPLink、STLINK、JTAG 等工具里挑了很久，包括网友们 DIY 的那些硬件，最后选了这个又贵销量又少的 STLINK-V3MINIE。\n为什么呢？\n首先是开发环境。我用的是 STM32CubeMX + VS Code + CMake 的工具链，配合 ST 官方的 STM32 VS Code Extension，这套工具链相对来说很新也挺好用，摆脱了对 Keil 和 STM32CubeIDE 的依赖。 但我担心非官方的调试器与这套工具链不兼容，所以我希望第一次买调试工具先挑选 “血统纯正” 的硬件。\n其次是性能。我上面提到的这个工具链使用了 Ninja，编译速度非常快，下载自然不能拖后腿。 STLINK-V3 的传输速度（理论 480 Mbit/s）比 V2（12 Mbit/s USB 2.0）快了许多，能节省不少调试时间。\n最后就是在 STLINK-V3MINIE、 STLINK-V3SET、 STLINK-V3PWR、 STLINK-V3MODS 里挑选了。V3SET 和 V3PWR 太贵，V3MODS 需要单独做载板，V3MINIE 刚好够用。\n开箱体验\rSTLINK-V3MINIE 官网售价是 11 美元，国内的零售价大概在 90 - 110 元间，比满天飞的十几块钱的 V2 贵不少。\nSTLINK V2 之所以便宜是因为它的固件在网上流通，因此存在大量的仿制品。官网上在售的 ST-LINK/V2 其实仍然很贵。\n这是 STLINK-V3MINIE 的包装和内容物：\n包装内含有 STLINK-V3MINIE 本体即一块 PCB，一根 1.27mm 14pin 的 FFC 接口排线，以及一份说明书（提示相关文档的地址）。\n我在这里放一张用户手册上提供的 STLINK-V3MINIE 的放大图片：\n从 Type-C 接口占整板的比例不难看出，STLINK-V3MINIE 的尺寸非常小，为 15.24mm x 43.47mm，和常规 USB 闪存盘的尺寸差不多。\n","date":"2025-03-02T10:47:00+08:00","image":"https://keinestudio.cn/posts/stlink-v3minie/image.PF271415.en.feature-description-include-personalized-no-cpn-large_hu_f27fcdd5ee0b6880.webp","permalink":"https://keinestudio.cn/posts/stlink-v3minie/","title":"玩一玩 STLINK-V3MINIE"},{"content":"本文是对 MAX14808 进行驱动测试时 STM32G474 定时器触发 DMA 高速翻转 GPIO 的实现过程。\n硬件准备\rMAX14808 Evaluation Board v1.0 STM32G474VET6 开发板 STM32G474 的最高时钟频率为 170 MHz，VET6 为 LQFP-100 封装。 STLINK-V3-MINIE 示波器 软件准备\rSTM32CubeMX，固件版本为 STM32Cube_FW_G4_V1.6.1 Visual Studio Code CMake（我从来不用 Keil，CubeIDE 也用不习惯） 思路\r为了让 MAX14808 输出实验要求的高压脉冲，需要以一定的时序向每个通道的 INN, INP 引脚输入逻辑信号。\n在输出高压脉冲时，INN, INP 需要以 10 MHz 的频率翻转。STM32 的 HAL 库 GPIO 操作是做不到的，需要用到 DMA。\n网上关于 DMA 翻转 GPIO 的方法并非没有，但主要都是测试 STM32 翻转 GPIO 的极限速度，像本文中这种输出特定频率脉冲的博文在我写这份笔记前还没看到过（之前用 NUCLEO-U575ZI 测试 MAX14808 时参考了 Solved: STM32U5 Triggering DMA request from timer to write to GPIOD ODR register，但 STM32U5 的 GPDMA 与其他系列的用法区别太大了）。\n我折腾了几天后搞出来以下结果。\n配置 CubeMX\r将 8 个通道的 16 个 IO 配置在 STM32G474 的 GPIOE0~E15 上，这样向 GPIOE-\u0026gt;ODR 写入一个 16 位二进制数便可同时操作 16 个引脚输出高 / 低电平。 配置 TIM2 用来生成 10 MHz 脉冲。MCU 主频先拉到最大 170 MHz，TIM2 不预分频，计数周期为 17 - 1，这样生成的脉冲就是 10 MHz。 以 TIM2_UP 为事件生成 DMA 请求（网上的文章这里都用 MemToMem 的 DMA 请求，但 MemToMem 的 DMA 突发传输速度由 AHB 时钟频率决定，不能直接控制）。模式选 Normal 而不是 Circular，原因后面说。方向当然是 Memory to Peripheral，数据宽度选 Half Word（STM32 是 32 位处理器嘛，一个字是 32 位，半个字就是 16 位）。 到目前为止我只提到了以 10 MHz 翻转 GPIO，但这个操作每 50 ms 才进行一次。假如我用 DMA Circular，将波形图的红线和绿线部分都扔进 DMA 搬运，那么波形数组内将会有 $50 \\times 10^{-3} \\cdot 10\\times 10^6 = 5 \\times 10^5$ 个数，内存估计爆了🤣。\n所以我们只能让 DMA 由另一个周期为 50 ms 的时钟触发，每次触发只搬运脉冲和两条红线的部分，搬完就停，直到下一次被 “唤醒”。这就是为什么要把 DMA 配置为 Normal。\n配置另一个时钟 TIM5（TIM2 和 TIM5 是 STM32G474 中的两个 32 位通用定时器，用它们计时更精准，我猜），预分频 1000 - 1，计数周期 8500 - 1，这样时钟频率就是 20 Hz。 开启 TIM5 的全局中断。我会在 TIM5 的中断中执行 DMA 传输。由于 DMA 由硬件执行而不经过 CPU，所以中断函数的运行速度很快。 再记录一下时钟树的配置。 CubeMX 其余的部分不重要，就不放出来了。\n代码\r只是操作 GPIO，代码并不长。其实只有 main.c 的几个片段：\n脉冲波形数组，PULSE_OFF 对应关断、PULSE_RECEIVE 对应打开 T/R 开关接收回波。根据前文思路，我只需要在波形数组的最后一位填 PULSE_RECEIVE，则传输结束后的剩余时间里 MAX14808 都处于接收状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Private macro -------------------------------------------------------------*/ /* USER CODE BEGIN PM */ #define PULSE_OFF 0x0000 #define PULSE_VPP 0xAAAA #define PULSE_VNN 0x5555 #define PULSE_RECEIVE 0xFFFF /* USER CODE END PM */ /* Private variables ---------------------------------------------------------*/ /* USER CODE BEGIN PV */ uint16_t pulse_wave[] = { PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_VPP, PULSE_VNN, PULSE_VPP, PULSE_VNN, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_OFF, PULSE_RECEIVE, }; extern DMA_HandleTypeDef hdma_tim2_up; /* USER CODE END PV */ 在 main 函数里启动 TIM5。MAX14808_Init 和 MAX14808_SetMode 是我自定义的两个函数，主要是对 MODE0 和 MODE1 两个引脚操作，控制 MAX14808 的整体工作状态，这里略过不提。 1 2 3 4 5 6 7 8 9 10 int main(void) { ... /* USER CODE BEGIN 2 */ MAX14808_Init(); MAX14808_SetMode(MAX14808_MODE_OCTAL_THREE_LEVEL); HAL_TIM_Base_Start_IT(\u0026amp;htim5); /* USER CODE END 2 */ ... } 编辑 TIM5 的中断回调函数，这里少一行代码都不行。为了让 DMA 能够重复触发，你必须： 关闭 DMA；停止并重置 TIM2；清除 DMA 状态；启动 DMA；启动 TIM2。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { /* USER CODE BEGIN Callback 0 */ if (htim-\u0026gt;Instance == TIM5) { __HAL_TIM_DISABLE_DMA(\u0026amp;htim2, TIM_DMA_UPDATE); HAL_TIM_Base_Stop(\u0026amp;htim2); __HAL_TIM_SET_COUNTER(\u0026amp;htim2, 0); HAL_DMA_Abort(\u0026amp;hdma_tim2_up); HAL_DMA_Start(\u0026amp;hdma_tim2_up, (uint32_t)pulse_wave, (uint32_t)\u0026amp;PULSE_GPIO_Port-\u0026gt;ODR, sizeof(pulse_wave)/sizeof(pulse_wave[0])); __HAL_TIM_ENABLE_DMA(\u0026amp;htim2, TIM_DMA_UPDATE); HAL_TIM_Base_Start(\u0026amp;htim2); } /* USER CODE END Callback 0 */ ... } 实验\r用示波器观察单个通道的 INN 和 INP 引脚：\n波形失真比较严重，我们猜测原因是信号频率高、示波器探头线太长、信号通过杜邦线连接出现多次反射等。但频率、相位都是很精准的。\n以下是 MAX14808 输出端空载观察到的波形：\n这个脉冲局部波形就更丑了，估计也是和电路连接方式有关。这些没办法靠写代码解决，只能等后面硬件方案改版再测试。\n小结\r由于之前没有系统的 STM32 软件开发经验，这次 MAX14808 的驱动实验我绕了很多弯路，甚至烧掉了我的 NUCLEO-U575ZI 开发板😵。但好在我最后找到了一个合格的控制方案，并且实验极大地加深了我对 STM32 MCU 的时钟和 DMA 的理解。\n感谢黄学长的笔记给我的启发以及曹学长的支持。\n","date":"2025-02-26T22:06:00+08:00","image":"https://keinestudio.cn/posts/stm32g474-dma/osc-gpio_hu_d2b28bbea023fc91.jpg","permalink":"https://keinestudio.cn/posts/stm32g474-dma/","title":"STM32G474 定时器触发 DMA 高速翻转 GPIO"},{"content":"又是一岁生日，例行回顾一下呗。\n深造\r上半年，因为感兴趣所以开始学着用嘉立创 EDA，正好大二下上课要学模拟电子技术基础和数字电子技术基础。 我做的第一个 PCB 诞生于 2024 年 5 月 9 日，其实就是一个 LCD 屏幕的转接板，没有电路。\n第 2 个 PCB 诞生于 6 月 1 日，是一个模拟调光的陶瓷 LED 灯板。 灵感嘛，就是想整点东方project 有关的创作。 这个电路除了电池电源管理用的成品模块，其他的电路均从零开始设计，也没有任何现成的参考。 其中最费时间的其实是 LED 的升压驱动芯片的选型，至少用了两个星期。\n我后来想给自己做的这些设计起个编号，像同人音乐社团的 CD 那样，于是就给这两个电路板起名叫 MXDS001 和 MXDS002。\n虽然本来就喜欢空想，但从这以后我不会任由灵感飞逝了，我会把它们记录下来，然后实现它们。 于是又有了 MXDS003，亲手画工图把桌面拓宽; MXDS004，3D 打印的理线器……\n直到今天，MXDS 系列已经来到了 MXDS010，其中还包括一些面向项目的设计。 我暂时没有把它们全部开源，因为懒得写文档，也没有什么复刻的价值。\n下半年我学习了用 Altium Designer，着手一些中大型项目。 在制作了十几个 PCB 后，我明显能感受到自己对电子系统有了一套理解。\n2025 年我计划学会高速 PCB 的设计，也许还会接触 FPGA 开发。\n唱吧，跳吧\r2024 年，去了两场 Touhou Only，两场东方乐典 Live 演出。 🥰\n对于一个从来没有参加过漫展和音乐会的学生，可以说是大饱眼福了。 我最意外的收获是发现自己先天 rave 圣体，跟着音乐特别能跳。\n这一年也在不断扩充音乐库，Trance 和 Progressive House 听多了后，我能分析出曲子中最基本的那些要素，也有了自己的一套评价标准。\n书架上收藏的 CD 数来到了二十有余，但不知道为什么买专辑前自己心心念念，买到了后反而不怎么听，尽管确实都是自己最喜欢的曲子。\n每个人都有自己排遣的方式，对于我而言，音乐已是最好的选择。 这是量变带来的效果，只要接触得足够多，自然会形成那种独特的品味。\n去年的这个时候，我面对自己无枝可栖的困境，写了很多悲伤的东西。 后来我释然了，很多事情本就没有必要一直操心，于是转身去开辟自己的天地。\n20 岁唯一的遗憾，是始终摆脱不了学生的习气，太听话了，别人说什么就是什么。\n既然下定决心要遵从自己的愿望，那么 21 岁就要继续修炼，把空想变成现实。\n","date":"2025-01-16T00:00:00+08:00","image":"https://keinestudio.cn/posts/21/61269686_p0_hu_2fbafb2bb1bca6a7.jpg","permalink":"https://keinestudio.cn/posts/21/","title":"21"},{"content":"\r配合音乐阅读更佳（\r2024 年 10 月 29 日是 HITSZ OpenAuto 的 1 岁生日。\n好几天前，成员们就在讨论庆祝的事情了。 想来想去，我们本身是基于互联网的团队，写点小文章纪念一下也是不错的选择。 结果我最先提出这个想法，反而是最后一个交作业的 😂。\n一开始有一些写作的想法，看到其他几位同学的博客后发现想出来的东西都被写过了，什么 HOA 的成长历程啊、参与开源的初衷啊、收获与致谢啊……这些都是很好的话题，但大家都写就没意思了。\n那，咱来聊点不一样的？\nHOA 网站的搭建，尤其是涉及到 HTML, CSS, JS 的部分基本上都是 @longlin li 和 @Kowyo 等人在做。 而我在 HOA 主要的工作，就是写。\n写什么呢？写课程描述，写博客，还有一些组织内部文案。 此外，由于强迫症，我重新排版了很多其他人写的文档。 这一年，写了不少东西，也读了不少别人写的东西。\n为什么要写博客，以及分享知识时的「面向陌生人」原则\r我相当享受用文字组织逻辑的过程（不是用文字倾泻情感，那是另一回事）。 如果你能用文字完整地描述一个事物，那么说明你对这个事物已经有了充足的理解。 这也是为什么很多人会用博客的方式记录自己学习的知识，包括学校里学习的课程，和课外自己搞开发时学习的技术。\n比如《平面简单桁架中零力杆的判断》 这篇 HOA 上的博客，是我在自学这个知识点后马上写下来的。 即使理论力学这门课的内容我今天已经忘掉了 90%，我仍然能随口说出零力杆的 4 种判断方法。\n你可能问了，这跟自己记的笔记有什么区别呢？\n笔记是记给你自己看的，自己看得懂就 OK 了，所以你可能在记笔记的时候并没有多加思考，或者记得很简略。 说不定过了一段时间，你已经看不懂自己过去的笔记了（\n而写博客的时候，你应该时刻提醒自己，博文的读者不是你，而是对你所写的内容完全陌生的人。 这也是我在 HOA 上写文档时反复提醒自己的一点。\n一篇知识型文章的出发点应当低于你想要描述的主体内容。 例如我想描述平面简单桁架中零力杆的判断方法，我就从质点的二维静力学平衡条件出发，逐个讲述每种特殊节点的判断原理。 这样对读者的筛选就会非常宽松，能够保证读有所得，并且你也能收获更多的阅读量。 这也是为什么网上自称「保姆级」「零基础」的教程往往更吸引眼球。 最重要的是，当那个读者是你自己的时候，你可以无负担地重新 get 到文章的完整内容，而不需要为了读懂它而去查找别的资料。\n另一方面，你以最通俗的方式描述知识的过程，其实就是把模棱两可的东西变得清晰的过程。 这样一来，你在回忆这个知识的时候就不存在任何思维负担了，因为你已经把它变成了一个完整的故事。\n如果写博文时不遵循「面向陌生人」原则，出发点等同于甚至高于主体内容，那么在外人看来，这篇文章就是单纯的作秀，炫耀自己会别人不会的东西。 这种博文，其实没有起到分享知识的作用。\n有点难理解？回忆一下你在 B 站上逛到的那些「开源」项目，哪些让你心动复刻，哪些你看了两眼就关掉了？\n知识共享平台的更多可能性\r所谓的「知识分享平台」其实很多，B 站上有不少知识区 up 主，微信有海量学习公众号，GitHub 上有许多开源社区，甚至自救群也算得上。\n我在这里想讨论的是 HOA 这样，面向中等规模群众（如 HITSZ 本科生）的开源社区。\n开源社区与其他类型平台的区别在于，所有的内容都透明公开，不存在任何商业利益。 对比之下，你并不知道 B 站 up 主或微信公众号的内部是如何运作的。 它们面向的是全网多数用户，并不一定能满足某个特定用户或者群体的全部需求。\n作为开源组织，我们可以深入地调查同学们的需要，然后根据反馈进行更新内容。 更重要的是，开源平台的 Pull Request 机制允许所有人参与到平台维护和内容创作中来。 这也是我认为最被忽视的一点。\n由于我们的内容是以网站的形式呈现给大家的，而真正的仓库托管在 GitHub 上，不少同学对 HOA 的印象可能还停留在类似「微信公众号」的组织。\n我们不是单向地向大家搬运信息！你所阅读到的文档、下载的资料，除了组织内部成员整理，还有无数普通学生的贡献。 所以我看到自救群里有人质问「HOA 上某某课程怎么没有资料」时，我其实是很无语的。 没有人有义务去上传这些资料，HOA 也只是提供了平台。\n因此，开源社区的活跃非常依赖用户与核心成员的双向互动。 如果只有核心成员在维护仓库，用户只是单向消费内容，那么 HOA 就和微信公众号一样，随时可以停更跑路；\n另一个极端就是自救群。 自救群的优势在于门槛和发言成本很低，用户参与度可以非常高。\n但是自救群有突出的问题：信息流量大，导致信息质量参差不齐，且时效性太强。\n举个例子，某同学在群里为一道题提供了非常优质的解答，但是很快就被后面的消息淹没了。 后来的学生遇到相同的问题，很难检索到这条消息。 虽然 QQ 群有诸如「精华消息」的功能，但精华消息设置得太多，其实就没有精华了。\n如果答主将解答以文件或者博客的形式上传到 HOA，就可以长期保存且不失曝光度。\nHOA 作为开源社区，可以在「双向交流」和「组织度」方面，一定程度上规避微信公众号和自救群的不足。 这也是我认为 HOA 重要的发展方向。\n我希望同学们能多多参与到 HOA 的维护中来 （其实我们已经有很多努力了，你会注意到大多数页面下方有评论区，我们也有专门的邮箱接受邮件，更别忘了你可以直接提 Pull Request！）， 这并不只是为了 HOA，你其实在这个过程中也会有非常多的收获。 你问能收获什么？我在本文第一部分就说过啦！\n总的来说，开源社区，也许是未来的知识分享平台的一种可能，会比公众号、自救群走得更远。\n闲言碎语，不成体系，但我希望这篇文章能给你一些启发。 最后，祝 HITSZ OpenAuto 生日快乐。我想在有生之年，看见你成为最棒的知识共享平台。\n关于参与维护，如果你不知道从哪里开始，看一看你正在学习哪一学期的课程，对应文档上有没有「过期」的内容？ 如果有，这就是你贡献的大好机会！ 试着更新一下课程的基本信息，就是你在 HOA 上的一次重要贡献！\n封面：フランの夢は睡深 36,000 歩 by こざくら\n","date":"2024-10-28T00:00:00+08:00","image":"https://keinestudio.cn/posts/sharing-knowledge/64894936_p0_hu_6373aef88df89a38.png","permalink":"https://keinestudio.cn/posts/sharing-knowledge/","title":"杂谈：关于分享知识"},{"content":"本文记录如何为 Linux 系统配置 SSH 密钥，以便在不输入用户名和密码的情况下连接 GitHub。\n参考：通过 SSH 连接到 GitHub - Github 文档\n检查现有 SSH 密钥\r1 ls -al ~/.ssh 检查输出结果中是否含有 id_rsa.pub / id_ecdsa.pub / id_ed25519.pub 文件。例如\n1 2 3 4 5 6 总用量 20 drwx------ 2 jay jay 4096 x月 xx xx:xx . drwxr-xr-x 30 jay jay 4096 x月 xx xx:xx .. -rw------- 1 jay jay 432 x月 xx xx:xx id_ed25519 -rw-r--r-- 1 jay jay 118 x月 xx xx:xx id_ed25519.pub -rw-r--r-- 1 jay jay 444 x月 xx xx:xx known_hosts 说明这个用户已经有一个 SSH 密钥了。\n当然，如果没有出现这些文件，或者用户目录下根本没有 .ssh 文件夹，那么说明该用户需要生成新的 SSH 密钥。\n生成新的 SSH 密钥\r输入以下命令，将 \u0026ldquo;your_email@example.com\u0026rdquo; 替换为 GitHub 邮箱地址。\n1 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 1 \u0026gt; Generating public/private ALGORITHM key pair. 当系统提示 \u0026ldquo;Enter a file in which to save the key（输入要保存密钥的文件）\u0026rdquo; 时，可以按 Enter 键接受默认文件位置。\n但如果已经有了已经有了一个密钥文件，则 ssh-keygen 可能会要求重写另一个密钥，在这种情况下，建议创建自定义命名的 SSH 密钥。\n1 \u0026gt; Enter a file in which to save the key (/home/YOU/.ssh/id_ALGORITHM):[Press enter] 如果想为 SSH 密钥添加密码，在下列提示出现时设置。\n1 2 \u0026gt; Enter passphrase (empty for no passphrase): [Type a passphrase] \u0026gt; Enter same passphrase again: [Type passphrase again] 将 SSH 密钥添加到 ssh-agent\r在后台启动 ssh 代理\r1 eval \u0026#34;$(ssh-agent -s)\u0026#34; 如果 ssh-agent 没有启动，输入 exec ssh-agent bash（或 zsh，取决于终端）。\n将 SSH 私钥添加到 ssh-agent\r1 ssh-add ~/.ssh/id_ed25519 如果使用其他名称创建了密钥，或要添加具有其他名称的现有密钥，请将命令中的 id_ed25519 替换为私钥文件的名称。\n添加 SSH 密钥到 GitHub\r1 cat ~/.ssh/id_ed25519.pub 将输出的内容复制到剪贴板。\n在 GitHub 网页上，点击右上角的头像，选择 Settings -\u0026gt; SSH and GPG keys -\u0026gt; New SSH key。 将复制的 SSH 密钥粘贴到 Key 输入框中，点击 Add SSH key。\n测试 SSH 连接\r1 ssh -T git@github.com 可能会出现以下提示：\n1 2 3 \u0026gt; The authenticity of host \u0026#39;github.com (IP ADDRESS)\u0026#39; can\u0026#39;t be established. \u0026gt; ED25519 key fingerprint is SHA256:.... \u0026gt; Are you sure you want to continue connecting (yes/no)? 验证所看到消息中的指纹是否与 GitHub 的公钥指纹匹配。如果是，则键入 yes：\n1 2 \u0026gt; Hi USERNAME! You\u0026#39;ve successfully authenticated, but GitHub does not \u0026gt; provide shell access. 之后，就可以在不输入用户名和密码的情况下连接 GitHub 了。\n从网站上克隆仓库的时候，记得使用 SSH 地址而不是 HTTPS。\n","date":"2024-09-27T16:35:00+08:00","permalink":"https://keinestudio.cn/posts/ssh-github/","title":"使用 SSH 连接 GitHub"},{"content":"本文以 Windows 11、WSL 2 和 Ubuntu 20.04 LTS 为例，记录从零开始配置 WSL 以及一些常用开发环境的过程。\n此外，本文提到的镜像源均指 HITSZ OSA Mirrors。配合校园网食用效果更佳。\n安装 WSL\r方法 1：直接在 Windows 应用商店搜索 Ubuntu，选择对应发行版点击安装。\n方法 2：使用 WSL 命令行安装。参考 如何使用 WSL 在 Windows 上安装 Linux - Microsoft Learn\n设置软件镜像源\rUbuntu 软件仓库镜像使用帮助 - MirrorZ Help\n/etc/apt/sources.list\n设置系统语言为中文\r安装中文语言包 1 sudo apt install language-pack-zh-hans 设置中文为默认语言 1 sudo dpkg-reconfigure locales 选中 en_US.UTF-8 和 zh-CN.UTF-8；选择 zh-CN.UTF-8 为默认语言\n安装字体管理工具 fontconfig 1 sudo apt install fontconfig 让 Linux 使用 Windows 已安装的字体 1 sudo nano /etc/fonts/local.conf 写入以下内容\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE fontconfig SYSTEM \u0026#34;fonts/dtd\u0026#34;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;dir\u0026gt;/mnt/c/Windows/Fonts\u0026lt;/dir\u0026gt; \u0026lt;/fontconfig\u0026gt; 也可将 C:\\Windows\\Fonts 中的字体复制到 /usr/local/share/fonts 目录下。\n刷新字体缓存 1 sudo fc-cache -fv 以上参考自 学习笔记：WSL Ubuntu 20.04 LTS 安装中文语言 - CSDN\n我最爱的 Oh My Posh\rHomebrew\nOh My Posh\n主题可以保存在 Windows 上，例如\n1 2 # ~/.bashrc eval \u0026#34;$(oh-my-posh init bash --config /mnt/d/.../lambdageneration.omp.json)\u0026#34; $LaTeX$ 编译器（以 TeX Live 2024 为例）\r从 OSA 镜像站的 CTAN/systems/texlive/Images 下载 texlive2024.iso 在 Windows 上装载光驱，记住对应盘符（如 F:） Ubuntu 上挂载光驱 1 2 sudo mkdir /mnt/texlive sudo mount -t drvfs F: /mnt/texlive 开始安装 1 sudo /mnt/texlive/install-tl 按照提示操作，等待选定的软件包被安装。\n记得添加环境变量到 .bashrc：\n1 2 3 4 # TeX Live export PATH=/usr/local/texlive/2024/bin/x86_64-linux:$PATH export MANPATH=/usr/local/texlive/2024/texmf-dist/doc/man:$MANPATH export INFOPATH=/usr/local/texlive/2024/texmf-dist/doc/info:$INFOPATH 安装完成后解除挂载状态，并删除安装包 1 2 sudo umount /mnt/texlive sudo rm -r /mnt/texlive/ 额外内容：让 Windows Powershell 能直接访问 WSL 的环境变量，建立到 TeX 的软连接。\n1 sudo /usr/local/texlive/2024/bin/x86_64-linux/tlmgr path add 在 Windows Powershell 中测试：\n1 wsl tex -v 你甚至可以在 Windows 下的 VS Code LaTeX Workshop 插件中使用 WSL 的编译器！ 修改 latex-workshop.latex.tools 的各个 \u0026quot;command\u0026quot; 即可。例：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026#34;latex-workshop.latex.tools\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;wsl xelatex\u0026#34;, // 注意这里 \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, ] ROS（以 ROS Noetic 为例）\r添加 OSA 镜像站的 ROS 源 1 sudo sh -c \u0026#39;echo \u0026#34;deb http://mirrors.osa.moe/ros/ubuntu/ focal main\u0026#34; \u0026gt; /etc/apt/sources.list.d/ros-latest.list\u0026#39; 手动编辑：\n1 2 # /etc/apt/sources.list.d/ros-latest.list deb https://mirrors.osa.moe/ros/ubuntu/ focal main 添加 ROS 的 GPG 密钥 以下两条命令二选一，任一成功即可。\n1 sudo apt-key adv --keyserver \u0026#39;hkp://keyserver.ubuntu.com:80\u0026#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 1 2 sudo apt install curl curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - 安装 ROS Noetic 桌面完整版 1 2 3 4 5 sudo apt update # 如果输出类似 #「命中:6 https://mirrors.osa.moe/ros/ubuntu focal Release」 # 则说明前 2 步成功 sudo apt install ros-noetic-desktop-full 设置环境变量 1 2 echo \u0026#34;source /opt/ros/noetic/setup.bash\u0026#34; \u0026gt;\u0026gt; ~/.bashrc # 添加 ROS 配置文件到环境变量 source ~/.bashrc # 使配置生效 安装 ROS 配套工具 1 sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 初始化 rosdep 这一步就 2 个命令：\n1 sudo rosdep init 1 rosdep update 如果没有科学上网，这一步可能会很困难。参考\nwin10 wsl2 + ubuntu20.04 配置 ROS-Noetic - CSDN\n和 ROS Distro 镜像使用帮助 - MirrorZ Help 解决。\n","date":"2024-09-01T11:08:00+08:00","image":"https://keinestudio.cn/posts/wsl-setup/neofetch_hu_5eda2930e9faa4b7.png","permalink":"https://keinestudio.cn/posts/wsl-setup/","title":"WSL 快速配置自查手册"},{"content":"我小时候，有一个习惯，那就是往地上看。 看地上有什么稀奇的小玩意，还会把它们捡起来。\n我那时候还没有近视，地上的东西我看得很清楚；身高也不高，因此地面对我来说非常近，轻轻一蹲就能够着地面。\n我从地上捡到过很多东西，硬币、包装纸、小石子、打火机的点火装置、昆虫、积木零件、BB 弹（玩具枪的子弹）…… 无一例外，我不嫌脏地把它们带回家拿给大人看，像乌鸦收藏闪闪发光的物品一样。\n父亲觉得我的行为很好笑，还给我取了个称号：“垃圾娃儿”（四川方言）\n当然，我捡到的很多东西基本上都没有保留到今天，因为它们中的大多数确实是垃圾。\n但是往地上看的习惯让我养成了敏锐的观察力，至少那个时候，老师还会称赞这一点。\n昨天晚上我沿着大沙河散步，顺便去逛商场。 时间大概是六七点，深圳这个时候还没有日落。\n我走在铺了沥青的步行道上，听着耳机里的音乐，手插裤兜，一副很享受的样子。\n我路过一大群在玩耍的小孩，围着健身设施上蹿下跳。\n看着那些小孩，我好像想起了什么似的（也许是因为小孩比成年人矮一截所以需要低头吧）往地上看去。\n我什么也没看见。\n这个念头着实使我吓了一跳。 眼前虽然是红色的柏油路面，但对于《小王子》中的那些 “grown-ups” 来说，等于空无一物。\n是的，我已经二十岁了。 我的身高在同龄人中仍是矮的，但确实已经比小孩高了很多。 而且，我戴上了眼镜。\n地面对我来说变得好远、变得好模糊。\n低头？对不起，会被人说弯腰驼背。\n蹲下去捡东西？对现在的我来说只是浪费本来就少的自由时间。\n我早已丢掉了往地上看的习惯，也看不清地上了。\n或许地上还会有什么小玩意能够引起我的兴趣，我已经不屑于去发现它们了。\n我当然希望自己还能发现一些普通人看不见的东西，可惜满地都是月亮的时候，我在仰望天上的六便士。\n","date":"2024-05-26T19:05:12+08:00","permalink":"https://keinestudio.cn/posts/look-down/","title":"往地上看"},{"content":"大概离生日前一个月就有写这篇博客的想法了。 这一个月里，各种各样的念头在脑中闪现，有些是一些自己觉得很有意思的句子，然而我很快就把它们给忘掉了；能想起来的那部分，也不知道该放在文章的哪一节。\n所以这篇文章看起来就像不肯在一张完整的稿纸上写字，而是非要把纸先撕碎，然后再在每一小片上写字一样。 但是大多数人的写作都好不到哪儿去，所以你也别在意这些。\n我的前 18 年\r我是独生子，出生在普通的家庭。 父母属于九十年代从农村里走进城市的那一批人，深知农民的辛苦，因此对于生活的要求就是轻松安稳。 但哪怕是“轻松安稳”，对于小老百姓来说也并非易事，因此哪怕他们用认真的态度对待教育，在我的眼中总有一种“活着就是为了活着”的感觉。\n我的童年过得并不圆满，很多那个年代流行的东西我都没有机会去接触。\n小孩子最想做的事情是玩，但家里人将我的活动范围限制在小区里，因此我常常只能在阳台上对楼下等我的邻居小伙伴说“你们去吧”。 在家里，我只能趁家长不在的时候玩电脑游戏。\n家里人让我去上各种兴趣班，播音主持、钢琴、水粉画、硬笔书法……都是一些有始无终的事情，尤其是用笔画画成了我最不擅长的。\n转机是一张小学放学时偶然拿到的广告单。 我参加了一个机器人的兴趣班，接触到 LEGO Mindstorms NXT，后来跟着老师去少年宫参与科创班，成了那里年龄最大的学生。 活动的内容就是使用基础的 DIY 材料和电子元件设计一些小玩意儿，小车、小灯、小风扇等等……\n虽然看上去很幼稚，但我找到了真正喜欢的东西。\n小学五年级，少年宫的老师带着我和同学去成都打 FLL (First LEGO League)；六年级去成都参加青少年科技创新大赛，都拿了省一等奖。\n那段时间是我整个小学时代为数不多成就感满满的时光。\n初中时为了升学，我不得不放下所有的兴趣爱好。 学校老师经常布置许多占用大量时间但没有意义的作业；每个周末、寒暑假都被补习班填满，为的是考进省里的重点高中。\n我在小学展现出一点点数学方面的天赋。但初中数学老师教得非常差，面向自主招生考试的补习班培训也不重视基础，难度非常高，说得通俗点就是技能树点歪了，这导致我的数学从初中开始就两头不讨好。 这一点的影响一直持续到了今天：大学工科对于数学的要求不低，然而我的各门数学课成绩都拖了后腿。\n幸运的是我最终如愿考上了重点高中，这应该是我人生中最惊险的一次跳跃，因为它彻底改变了我的人生轨迹，否则在地方的普通高中，几乎是没有机会进入好的大学的。\n我的高中虽然对学习要求很严格，但好在对学生的压迫并不像衡水模式那样严酷，平时还能抽出时间休息。\n我很喜欢我的高中老师和同学们，接触到大城市里的人让我的精神世界得到了极大的拓展。\n但比较可惜的是，我仍没有机会去发展科创方面的爱好。开学时我加入了校里的机器人社团，但是第一天活动就被告知社团解散了，因为没有指导老师。 家长和老师都只盯着高考，所以我也没办法自己捣鼓别的东西。\n高考的分数比我预期的低了十来分的样子，但还在能接受的范围内。\n填报志愿时我和家里人纠结了很久，最后家人同意了我的想法：\n我要重拾我儿时的梦想，做自己最喜欢的事情。\n大学\r我之所以想学自动化，是受到小时候接触的机器人的影响。 我对于这种软硬件结合的东西更感兴趣，因此我放弃了纯软件方向的计算机，尽管在 HITSZ，计算机一直是最强势的专业，并且我的高考分数完全可以进入。\n受到前文数学学习经历的影响，我在大学目前为止的成绩只能说还行，数理基础课都多少拖了后腿。\n然后就是一些我在⌈关于⌋里提到过的经历了。\n危机与希望\r我的前十八年几乎就是为了把自己送进大学而存在的，我为了这个目标牺牲了很多： 没有读很多思想深刻的书、没有去过很多地方旅游、几乎没有交朋友……\n我必须感谢过去的自己，让我有今天的命运； 但我一点也不怀念我的过去，因为我已经错过了太多东西，当我意识到这一点时，我正在错过更多。\n当我在网上看到某些初中生、高中生分享自己的编程作品或者电子设计，并且收到网友的各种评价的时候，我其实是非常难过的，因为这些人的行为仿佛在嘲笑我为什么我在那个年纪一事无成。\n这当然是一种非常自我中心的、不健康的心态，所以我选择了告诉自己不要那么去做。\n久而久之，我心中有什么想法都不愿意说给别人听了，因为在我的哲学里任何思维都是不完美的，注定会遭到他人的批评。 而且就目前我认识的人来看，也几乎没有人能够用一种相对客观友好的态度和我交流这类问题。 即使有，我也不想去打扰他们。\n尤其是到了大学，很不巧我的同班同学们表现得相当的内向，大家都在自己的圈子里生活。 我和其他人的兴趣爱好相差甚远，以至于一年多了，我也没有交到真正意义上的朋友，最多就是一些在办正事时会合作的熟人。\n身边随处是实力强大的同龄人，当我认识他们时我就已经意识到其中的一些是我用大学四年也追赶不上的。 虽然许多人会说这是一个很好的学习的机会，也有人鼓动我“向上社交”，但实际上哪有那么容易呢？\n当你意识到身边的人和你存在利益冲突的时候，真诚就几乎不存在了。\n一年多来，我不仅没有建立任何所谓的“深交”，反而在心中四处树立假想敌，荒唐地讨厌、蔑视、远离那些同龄人。\n这种恨，没有源头，没有结果，只会给自己带去痛苦与折磨，忘记自己为了什么而活着。\n仅仅度过了一个学期，我便进入了终日寡言的状态——一天只在购物或用餐的时刻，向店员挤出一两句选择或确认的字词，除此之外声带便可有可无； 有时候甚至于连这些声音也懒得发出了，连续 24 小时，除了沉默还是沉默。\n即时通讯软件的消息列表也整天空空如也，在一些群聊里旁观其他人为了鸡毛蒜皮的事情大费口舌，我甚至感叹人其实有这么多力气用来说话。\n住在荒岛上的鲁滨逊尚有《圣经》用来与上帝对话，我比鲁滨逊还不如。\n我害怕孤独，我不想就这样和世界的联系断开，那样的话，活着跟死了没有区别。\n我选择了戴上耳机，成瘾般地沉浸在音乐中。 音乐唤我醒来，伴我工作，助我入眠。 耳膜不停地震动，世界又恢复了一点生机。\n懂礼貌的人不会打扰戴上耳机的人，所以这样只会让日常中的交流进一步变得更少。 也就是说，治标不治本，与世界切断联系的那一天终将到来，而且是提前到来。\n转机是 HITSZ OpenAuto。 在独自修炼技术的过程中我逐渐深入接触开源文化。\n互助与共享对我来说比在考试或者竞赛中打败其他人更加有成就感。 如果可以的话，我愿意终生活在开源社区里。\n我还没有丢掉自己的初心，但我在接下来很长的时光里不得不为自己的生计奔波。 在跃向自由王国之前，我只能在必然王国里苟且。\n寻找救赎的路，好长啊。\n写在最后\r20 岁是一个重要的里程碑。 当你的年龄以 \u0026ldquo;2\u0026rdquo; 开头之后，你便失去了当小孩的资格； 肩上的负担也会日复一日的增加，只因你的年龄以 \u0026ldquo;2\u0026rdquo; 开头。\n人类社会一切不完美的存在，都可以归因于一句 “人会死”。\n在 19 岁的最后几天，我在脑海中生成了这样一段文字：\n人的意义在于留下了什么，而不在于拥有过什么。\n这是我在年龄以 \u0026ldquo;1\u0026rdquo; 开头时，对这个世界予我的审讯的回答。 我要用它来反驳长辈“为活而活”，用它来反驳同龄人的零和博弈，用它来反驳社会加以所有纯洁的人的迫害。\n如果你不喜欢这样的说法，那就随你便吧，这是我在年龄以 \u0026ldquo;1\u0026rdquo; 开头时说的，小孩子说的话不算数。\n20 岁生日到来的这一天，判决书下来了，我 “自愿” 被放逐了。\n苦修，从现在才开始。\n","date":"2024-01-16T00:00:00+08:00","permalink":"https://keinestudio.cn/posts/20/","title":"20"},{"content":"最近在尝试使用 WSL 2 作为开发 ESP-32 的工具，但是 WSL 不像 VMWare 虚拟机那样可以直接访问硬件，而是一个纯虚拟环境，无法直接访问 USB 设备，所以需要一些额外的工具来实现 USB 设备的共享。\n参考资料：WSL/连接 USB 设备 - Microsoft Learn\n2024.1.10 更新：usbipd 更新到了 4.0.0 版本，指令有所变化，本文已更新。\n先决条件\rWindows 11（内部版本 22000 或更高版本） 具有 x64/x86 处理器的计算机 Linux 发行版已安装并设置为 WSL 2（本次使用的是 Ubuntu 20.04 LTS） 安装 USPIPD-WIN 项目\r方法 1：从 GitHub 下载安装\r仓库链接：usbipd-win\n方法 2：使用 Windows 程序包管理器程序 (winget) 安装\r打开 PowerShell 并运行以下命令：\n1 winget install --interactive --exact dorssel.usbipd-win 在 Linux 中安装 USBIP 工具和硬件数据库\r在 Ubuntu 中，运行以下命令安装工具和硬件数据库：\n1 sudo apt install linux-tools-generic hwdata 为了启用 USBIP 服务，运行以下命令：\n1 sudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20 附加 USB 设备\r通过管理员模式打开 PowerShell 并运行以下命令，列出所有连接到 Windows 的 USB 设备：\n1 usbipd list 本次实验连接的是一个 ESP-32 DevKit-C，输出如下：\n1 2 3 4 5 6 7 8 9 10 11 Connected: BUSID VID:PID DEVICE STATE 1-3 0b05:19b6 USB 输入设备 Not shared 2-1 10c4:ea60 CP2102 USB to UART Bridge Controller Not shared 2-2 258a:0049 USB 输入设备 Not shared 2-3 13d3:3568 MediaTek Bluetooth Adapter Not shared 3-1 13d3:56eb USB2.0 HD UVC WebCam, USB2.0 IR UVC WebCam, Camera DFU De... Not shared Persisted: GUID DEVICE 2ca6f2f5-41c6-431c-ac86-44107478c8da USB-SERIAL CH340 (COM5) 这里面 CP2102 USB to UART Bridge Controller 就是我们想要连接的开发板了，它的设备总线 ID 是 2-1。\n选择要附加到 WSL 的设备总线 ID，然后共享出去：\n1 usbipd bind -b \u0026lt;bus_id\u0026gt; 其中 \u0026lt;bus_id\u0026gt; 是要共享的设备总线 ID，即步骤 1 中输出的“2-1”。\n这一步对于一个 USB 设备只需要执行一次，它的 STATE 就会变成 Shared。\n然后运行以下命令：\n1 usbipd attach -b \u0026lt;bus_id\u0026gt; --wsl 同样，\u0026lt;bus_id\u0026gt; 是要附加的设备总线 ID，即“2-1”。 此时设备就会从 Windows 上断开连接，并且在 WSL 上显示为一个 USB 设备。\n如果没有执行第 2 步的命令，那么 usbipd 会报错：\n1 usbipd: error: Device is not shared; run \u0026#39;usbipd bind -b 2-1\u0026#39; as administrator first. 在 Ubuntu 中，运行以下命令，列出所有连接到 WSL 的 USB 设备：\n1 lsusb 然后就成功显示到了开发板：\n测试连接以及断开连接\r我提前在 WSL 上用 esp-idf 工具链编译了一个简单的 hello-world 程序，现在尝试用 esp-idf 工具链将 WSL 中的项目烧录到开发板上。\n通过 ls /dev/tty* 命令查找到开发板的串口设备为 /dev/ttyUSB0，所以可以运行以下命令烧录程序：\n1 idf.py -p /dev/ttyUSB0 flash 我也尝试了直接使用设备总线 ID 来烧录程序，但没有成功……\n1 idf.py -p /dev/bus/usb/002/001 flash 输出如下：\n1 2 3 4 5 6 esptool.py v3.3.4-dev Serial port /dev/bus/usb/002/001 Traceback (most recent call last): File \u0026#34;/home/jay/.espressif/python_env/idf4.4_py3.8_env/lib/python3.8/site-packages/serial/serialposix.py\u0026#34;, line 322, in open self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK) PermissionError: [Errno 13] Permission denied: \u0026#39;/dev/bus/usb/002/001\u0026#39; 嘛，不管那个了，运行串口监视器，可以看到开发板是正常运行的：\n1 idf.py -p /dev/ttyUSB0 monitor 使用结束后，其实可以直接将 USB 设备从电脑上拔出，或者在管理员模式下运行 PowerSheell 命令来断开连接：\n1 usbipd detach -b \u0026lt;busid\u0026gt; 粗暴一点，可以直接断开所有的 USB 设备：\n1 usbipd detach --all 实际操作下来，使用命令断开 WSL 的 USB 连接后，Windows 上的设备管理器中又显示出了设备。\n（新功能）自动重连\rusbipd 在 4.0.0 版本后增加了自动重连功能，也就是说，我们可以仅通过运行一个命令让电脑一直检测 USB 设备的连接状态，如果设备被物理断连后重新接入，则自动重新连接到 WSL。\n1 usbipd attach -a --busid \u0026lt;bus_id\u0026gt; --wsl 其中 -a 等效于 --auto-attach，表示在设备断开连接后自动重新连接。\n演示效果：\n1 2 3 4 5 6 7 8 9 10 11 12 usbipd: info: Using WSL distribution \u0026#39;Ubuntu-20.04\u0026#39; to attach; the device will be available in all WSL 2 distributions. usbipd: info: Using IP address 172.30.208.1 to reach the host. usbipd: info: Starting endless attach loop; press Ctrl+C to quit. WSL wsl: �hKm0R localhost �NtM�n �FO*g\\��P0R WSL0NAT !j_ N�v WSL WSL N/ec localhost �Nt0 WSL WSL Attached WSL Detached \u0026lt;- 设备此时被拔出 WSL usbip: error: Attach Request for 2-1 failed - Device not found \u0026lt;- 系统发现设备断开 WSL Attached \u0026lt;- 重新插入设备后再次连接 这对于需要反复插拔的单片机开发板来说就相当方便了。\n","date":"2024-01-10T20:56:12+08:00","image":"https://keinestudio.cn/posts/wsl-connect-usb/ESP32-Devkit_hu_f90cd60db884e52a.jpg","permalink":"https://keinestudio.cn/posts/wsl-connect-usb/","title":"将 USB 设备连接到 WSL"},{"content":"刚考完复变函数与积分变换，有一个星期可以喘息一下了。 我闲得没事干，就开始在 Microsoft Learn 上学习 C#。\n普通的注释方法怎么你了？\r和以前学习 C 和 C++ 一样，我又回到了那个照着例程抄写、反复调试运行的过程。 这里面将代码注释掉是一个常见的操作。 一般来说，我们要想注释一行 C 语言风格的代码（对 C/C++/C# 都适用），常用 //：\n1 // printf(\u0026#34;Hello, world!\\n\u0026#34;); 如果是一大段的代码，我们常用 /* */：\n1 2 3 4 5 6 7 /* int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } */ 但是这两种方法都有一定的不方便的地方。 首先，对于第一种注释方法，即使 VS Code 有 Ctrl+/ 快捷键，但是每一行都要加上 // 还是有点麻烦。 而且对于像我这种书写格式强迫症来说，当我看到以下第 2 行的注释时，我会忍不住给它加个空格变成第 1 行的样子：\n1 2 // printf(\u0026#34;Hello, world!\\n\u0026#34;); //printf(\u0026#34;Hello, world!\\n\u0026#34;); 其次，对于第二种注释方法，一旦在一个文件里用得太多了，往往会使代码变得非常难看。\n1 2 3 4 5 6 7 8 /* int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } */ // ↑ 在一个 } 下面又是一个 */，让函数看上去非常不舒服 而且要想删掉这段注释，就必须既删掉这段注释的开头 /*，又要删掉注释的结尾 */，否则整个文件都会出问题，非常麻烦。\n最近我又在一些库文件中看到了另一种注释方法，那就是利用 if 和 endif：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #if 0 // 以下代码块不会出现在编译后的文件中 int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } #endif #if 1 // 激活以下代码块 int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } #endif 这种方法通过在 if 0 和 if 1 之间切换来实现代码块的禁用和激活，严格意义上来说不属于注释语法，\n一种实用的注释方法\r这个时候我想起来了过去在 HITSZ-VEX 程序组培训时，Longbin 教给我们的一种注释方法。 它的内容是，在要注释的代码块开头和结尾都添加一行 //*/\n1 2 3 4 5 6 //*/ int a = 0; int b = 1; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, a + b); printf(\u0026#34;Hello, world!\\n\u0026#34;); //*/ 在这种情况下，代码仍是有效的。 如果想要注释掉这段代码，只需将第一个 //*/ 改为 /*/。\n1 2 3 4 5 6 /*/ \u0026lt;- 只删掉了一个 \u0026#39;/\u0026#39; int a = 0; int b = 1; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, a + b); printf(\u0026#34;Hello, world!\\n\u0026#34;); //*/ 如果想要再次激活这段代码，那么把 /*/ 改回 //*/ 就行了。\n它的原理是什么？\r原理很简单，就是利用了 C 语言的注释规则。\n在 C/C++/C# 中，// 之后的内容都会被视为注释，直到这一行的结尾。 而 /* 之后的内容都会被视为注释，直到遇到 */。\n所以只需要一张图就可以解释这种注释方法的原理：\n下面我来介绍一下这种注释方法的几个用处。\n有什么用呢？\r学习 C/C++/C#\r初学一种编程语言时，我们往往会照着例程抄写，然后反复调试运行。\n例如我正在学习 C# 的逻辑运算，Microsoft Learn 上的培训给了若干示例代码。 我想把它们都记录下来，但测试运行效果时，我只想运行我最新抄写下来的那一段代码，因此我的文件看起来是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /*/ 相等运算符 Console.WriteLine(\u0026#34;a\u0026#34; == \u0026#34;a\u0026#34;); Console.WriteLine(\u0026#34;a\u0026#34; == \u0026#34;A\u0026#34;); Console.WriteLine(1 == 2); string myValue = \u0026#34;a\u0026#34;; Console.WriteLine(myValue == \u0026#34;a\u0026#34;); //*/ /*/ string value1 = \u0026#34; a\u0026#34;; string value2 = \u0026#34;A \u0026#34;; Console.WriteLine(value1.Trim().ToLower() == value2.Trim().ToLower()); //*/ /*/ 比较运算符 Console.WriteLine(1 \u0026gt; 2); Console.WriteLine(1 \u0026lt; 2); Console.WriteLine(1 \u0026gt;= 1); Console.WriteLine(1 \u0026lt;= 1); //*/ //*/ 返回布尔值的方法 string pangram = \u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;; Console.WriteLine(pangram.Contains(\u0026#34;fox\u0026#34;)); Console.WriteLine(pangram.Contains(\u0026#34;cow\u0026#34;)); //*/ 当我想要回头测试前面的代码块时，我只需修改两处地方，一个是把要激活的代码块的 /*/ 改为 //*/，另一个是把要禁用的代码块的 //*/ 改为 /*/。\n概括下来，只需一次删除操作和一次添加操作，就可以实现代码块的切换。\n读者可以设想或实验一下使用普通的注释方法 // 和 /* */，以上的内容要怎么写才能达到同样的效果、至少会使用到多少次删除和添加的操作。\n懂了吧？😏\n调试程序\r无论是机器人制作还是嵌入式开发，我们往往会对一些顺序执行的流程进行调试。\n例如我曾经还在 HITSZ-VEX 的时候，我们的机器人自动程序大概是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void autonomous() { //* ----- Begin ----- SomeNamespace::SomeClass::SomeFunction(); SomeNamespace::SomeTask *task = new SomeNamespace::SomeTask(someParams); // Some other code //*/ //*/ ----- Stage 1 ----- function1(); ... //*/ //*/ ----- Stage 2 ----- function2(); ... //*/ //*/ ----- Stage 3 ----- funtion3(); ... //*/ //*/ ----- End ----- // 一组动作 delete task; } 我们在开发调试时，经常需要只测试其中的某个 stage，或者暂时跳过某些 stage，那么只需在 //*/ ----- Stage x ----- 与 /*/ ----- Stage x ----- 之间进行切换。 因此这种注释方法就能在尽可能减少对代码的破坏的同时，实现高效率的调试。\n总结\r总结一下，本文介绍了一种 C/C++/C# 风格的注释方法\n1 2 3 4 5 6 7 //*/ 一行或多行激活的代码 int a = 0; //*/ /*/ 一行或多行被注释的代码 int b = 0; //*/ 这种注释方法有以下几个优点：\n只需少量操作就可以实现代码块的注释与取消注释 由于对注释的增删操作是在代码所在行之外进行的，所以不容易破坏代码块的内容 美观，可以在 //*/ 后书写额外的内容，方便对代码块进行标注 希望读者能够寻找到这种注释方法的更多应用场景，为自己的 C/C++/C# 学习和开发带来便利。\n","date":"2023-11-28T11:04:03+08:00","image":"https://keinestudio.cn/posts/a-useful-code-annotation/screenshot_hu_4b99f81eb7b32011.png","permalink":"https://keinestudio.cn/posts/a-useful-code-annotation/","title":"一种实用的 C/C++/C# 代码注释方法"},{"content":"2023 年 11 月 17 日，Maxwell Jay 的幻想乡正式建成。\n","date":"2023-11-17T16:22:12+08:00","permalink":"https://keinestudio.cn/posts/hello-world/","title":"你好，世界！"}]