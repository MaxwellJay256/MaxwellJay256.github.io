[{"content":"最近在尝试使用 WSL 2 作为开发 ESP-32 的工具，但是 WSL 不像 VMWare 虚拟机那样可以直接访问硬件，而是一个纯虚拟环境，无法直接访问 USB 设备，所以需要一些额外的工具来实现 USB 设备的共享。\n参考资料：WSL/连接 USB 设备 - Microsoft Learn\n2024.1.10 更新：usbipd 更新到了 4.0.0 版本，指令有所变化，本文已更新。\n先决条件 Windows 11（内部版本 22000 或更高版本） 具有 x64/x86 处理器的计算机 Linux 发行版已安装并设置为 WSL 2（本次使用的是 Ubuntu 20.04 LTS） 安装 USPIPD-WIN 项目 方法 1：从 GitHub 下载安装 仓库链接：usbipd-win\n方法 2：使用 Windows 程序包管理器程序 (winget) 安装 打开 PowerShell 并运行以下命令：\n1 winget install --interactive --exact dorssel.usbipd-win 在 Linux 中安装 USBIP 工具和硬件数据库 在 Ubuntu 中，运行以下命令安装工具和硬件数据库：\n1 sudo apt install linux-tools-generic hwdata 为了启用 USBIP 服务，运行以下命令：\n1 sudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20 附加 USB 设备 通过管理员模式打开 PowerShell 并运行以下命令，列出所有连接到 Windows 的 USB 设备：\n1 usbipd list 本次实验连接的是一个 ESP-32 DevKit-C，输出如下：\n1 2 3 4 5 6 7 8 9 10 11 Connected: BUSID VID:PID DEVICE STATE 1-3 0b05:19b6 USB 输入设备 Not shared 2-1 10c4:ea60 CP2102 USB to UART Bridge Controller Not shared 2-2 258a:0049 USB 输入设备 Not shared 2-3 13d3:3568 MediaTek Bluetooth Adapter Not shared 3-1 13d3:56eb USB2.0 HD UVC WebCam, USB2.0 IR UVC WebCam, Camera DFU De... Not shared Persisted: GUID DEVICE 2ca6f2f5-41c6-431c-ac86-44107478c8da USB-SERIAL CH340 (COM5) 这里面 CP2102 USB to UART Bridge Controller 就是我们想要连接的开发板了，它的设备总线 ID 是 2-1。\n选择要附加到 WSL 的设备总线 ID，然后共享出去：\n1 usbipd bind -b \u0026lt;bus_id\u0026gt; 其中 \u0026lt;bus_id\u0026gt; 是要共享的设备总线 ID，即步骤 1 中输出的“2-1”。\n这一步对于一个 USB 设备只需要执行一次，它的 STATE 就会变成 Shared。\n然后运行以下命令：\n1 usbipd attach -b \u0026lt;bus_id\u0026gt; --wsl 同样，\u0026lt;bus_id\u0026gt; 是要附加的设备总线 ID，即“2-1”。 此时设备就会从 Windows 上断开连接，并且在 WSL 上显示为一个 USB 设备。\n如果没有执行第 2 步的命令，那么 usbipd 会报错：\n1 usbipd: error: Device is not shared; run \u0026#39;usbipd bind -b 2-1\u0026#39; as administrator first. 在 Ubuntu 中，运行以下命令，列出所有连接到 WSL 的 USB 设备：\n1 lsusb 然后就成功显示到了开发板：\n测试连接以及断开连接 我提前在 WSL 上用 esp-idf 工具链编译了一个简单的 hello-world 程序，现在尝试用 esp-idf 工具链将 WSL 中的项目烧录到开发板上。\n通过 ls /dev/tty* 命令查找到开发板的串口设备为 /dev/ttyUSB0，所以可以运行以下命令烧录程序：\n1 idf.py -p /dev/ttyUSB0 flash 我也尝试了直接使用设备总线 ID 来烧录程序，但没有成功……\n1 idf.py -p /dev/bus/usb/002/001 flash 输出如下：\n1 2 3 4 5 6 esptool.py v3.3.4-dev Serial port /dev/bus/usb/002/001 Traceback (most recent call last): File \u0026#34;/home/jay/.espressif/python_env/idf4.4_py3.8_env/lib/python3.8/site-packages/serial/serialposix.py\u0026#34;, line 322, in open self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK) PermissionError: [Errno 13] Permission denied: \u0026#39;/dev/bus/usb/002/001\u0026#39; 嘛，不管那个了，运行串口监视器，可以看到开发板是正常运行的：\n1 idf.py -p /dev/ttyUSB0 monitor 使用结束后，其实可以直接将 USB 设备从电脑上拔出，或者在管理员模式下运行 PowerSheell 命令来断开连接：\n1 usbipd detach -b \u0026lt;busid\u0026gt; 粗暴一点，可以直接断开所有的 USB 设备：\n1 usbipd detach --all 实际操作下来，使用命令断开 WSL 的 USB 连接后，Windows 上的设备管理器中又显示出了设备。\n（新功能）自动重连 usbipd 在 4.0.0 版本后增加了自动重连功能，也就是说，我们可以仅通过运行一个命令让电脑一直检测 USB 设备的连接状态，如果设备被物理断连后重新接入，则自动重新连接到 WSL。\n1 usbipd attach -a --busid \u0026lt;bus_id\u0026gt; --wsl 其中 -a 等效于 --auto-attach，表示在设备断开连接后自动重新连接。\n演示效果：\n1 2 3 4 5 6 7 8 9 10 11 12 usbipd: info: Using WSL distribution \u0026#39;Ubuntu-20.04\u0026#39; to attach; the device will be available in all WSL 2 distributions. usbipd: info: Using IP address 172.30.208.1 to reach the host. usbipd: info: Starting endless attach loop; press Ctrl+C to quit. WSL wsl: �hKm0R localhost �NtM�n �FO*g\\��P0R WSL0NAT !j_ N�v WSL WSL N/ec localhost �Nt0 WSL WSL Attached WSL Detached \u0026lt;- 设备此时被拔出 WSL usbip: error: Attach Request for 2-1 failed - Device not found \u0026lt;- 系统发现设备断开 WSL Attached \u0026lt;- 重新插入设备后再次连接 这对于需要反复插拔的单片机开发板来说就相当方便了。\n","date":"2024-01-10T20:56:12+08:00","image":"https://maxwelljay256.github.io/posts/wsl-connect-usb/ESP32-Devkit_hu053b9317d90769e57a9b8211317cf12c_1799982_120x120_fill_q75_box_smart1.jpg","permalink":"https://maxwelljay256.github.io/posts/wsl-connect-usb/","title":"将 USB 设备连接到 WSL"},{"content":"刚考完复变函数与积分变换，有一个星期可以喘息一下了。 我闲得没事干，就开始在 Microsoft Learn 上学习 C#。\n普通的注释方法怎么你了？ 和以前学习 C 和 C++ 一样，我又回到了那个照着例程抄写、反复调试运行的过程。 这里面将代码注释掉是一个常见的操作。 一般来说，我们要想注释一行 C 语言风格的代码（对 C/C++/C# 都适用），常用 //：\n1 // printf(\u0026#34;Hello, world!\\n\u0026#34;); 如果是一大段的代码，我们常用 /* */：\n1 2 3 4 5 6 7 /* int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } */ 但是这两种方法都有一定的不方便的地方。 首先，对于第一种注释方法，即使 VS Code 有 Ctrl+/ 快捷键，但是每一行都要加上 // 还是有点麻烦。 而且对于像我这种书写格式强迫症来说，当我看到以下第 2 行的注释时，我会忍不住给它加个空格变成第 1 行的样子：\n1 2 // printf(\u0026#34;Hello, world!\\n\u0026#34;); //printf(\u0026#34;Hello, world!\\n\u0026#34;); 其次，对于第二种注释方法，一旦在一个文件里用得太多了，往往会使代码变得非常难看。\n1 2 3 4 5 6 7 8 /* int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } */ // ↑ 在一个 } 下面又是一个 */，让函数看上去非常不舒服 而且要想删掉这段注释，就必须既删掉这段注释的开头 /*，又要删掉注释的结尾 */，否则整个文件都会出问题，非常麻烦。\n最近我又在一些库文件中看到了另一种注释方法，那就是利用 if 和 endif：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #if 0 // 以下代码块不会出现在编译后的文件中 int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } #endif #if 1 // 激活以下代码块 int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } #endif 这种方法通过在 if 0 和 if 1 之间切换来实现代码块的禁用和激活，严格意义上来说不属于注释语法，\n一种实用的注释方法 这个时候我想起来了过去在 HITSZ-VEX 程序组培训时，Longbin 教给我们的一种注释方法。 它的内容是，在要注释的代码块开头和结尾都添加一行 //*/\n1 2 3 4 5 6 //*/ int a = 0; int b = 1; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, a + b); printf(\u0026#34;Hello, world!\\n\u0026#34;); //*/ 在这种情况下，代码仍是有效的。 如果想要注释掉这段代码，只需将第一个 //*/ 改为 /*/。\n1 2 3 4 5 6 /*/ \u0026lt;- 只删掉了一个 \u0026#39;/\u0026#39; int a = 0; int b = 1; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, a + b); printf(\u0026#34;Hello, world!\\n\u0026#34;); //*/ 如果想要再次激活这段代码，那么把 /*/ 改回 //*/ 就行了。\n它的原理是什么？ 原理很简单，就是利用了 C 语言的注释规则。\n在 C/C++/C# 中，// 之后的内容都会被视为注释，直到这一行的结尾。 而 /* 之后的内容都会被视为注释，直到遇到 */。\n所以只需要一张图就可以解释这种注释方法的原理：\n下面我来介绍一下这种注释方法的几个用处。\n有什么用呢？ 学习 C/C++/C# 初学一种编程语言时，我们往往会照着例程抄写，然后反复调试运行。\n例如我正在学习 C# 的逻辑运算，Microsoft Learn 上的培训给了若干示例代码。 我想把它们都记录下来，但测试运行效果时，我只想运行我最新抄写下来的那一段代码，因此我的文件看起来是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /*/ 相等运算符 Console.WriteLine(\u0026#34;a\u0026#34; == \u0026#34;a\u0026#34;); Console.WriteLine(\u0026#34;a\u0026#34; == \u0026#34;A\u0026#34;); Console.WriteLine(1 == 2); string myValue = \u0026#34;a\u0026#34;; Console.WriteLine(myValue == \u0026#34;a\u0026#34;); //*/ /*/ string value1 = \u0026#34; a\u0026#34;; string value2 = \u0026#34;A \u0026#34;; Console.WriteLine(value1.Trim().ToLower() == value2.Trim().ToLower()); //*/ /*/ 比较运算符 Console.WriteLine(1 \u0026gt; 2); Console.WriteLine(1 \u0026lt; 2); Console.WriteLine(1 \u0026gt;= 1); Console.WriteLine(1 \u0026lt;= 1); //*/ //*/ 返回布尔值的方法 string pangram = \u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;; Console.WriteLine(pangram.Contains(\u0026#34;fox\u0026#34;)); Console.WriteLine(pangram.Contains(\u0026#34;cow\u0026#34;)); //*/ 当我想要回头测试前面的代码块时，我只需修改两处地方，一个是把要激活的代码块的 /*/ 改为 //*/，另一个是把要禁用的代码块的 //*/ 改为 /*/。\n概括下来，只需一次删除操作和一次添加操作，就可以实现代码块的切换。\n读者可以设想或实验一下使用普通的注释方法 // 和 /* */，以上的内容要怎么写才能达到同样的效果、至少会使用到多少次删除和添加的操作。\n懂了吧？😏\n调试程序 无论是机器人制作还是嵌入式开发，我们往往会对一些顺序执行的流程进行调试。\n例如我曾经还在 HITSZ-VEX 的时候，我们的机器人自动程序大概是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void autonomous() { //* ----- Begin ----- SomeNamespace::SomeClass::SomeFunction(); SomeNamespace::SomeTask *task = new SomeNamespace::SomeTask(someParams); // Some other code //*/ //*/ ----- Stage 1 ----- function1(); ... //*/ //*/ ----- Stage 2 ----- function2(); ... //*/ //*/ ----- Stage 3 ----- funtion3(); ... //*/ //*/ ----- End ----- // 一组动作 delete task; } 我们在开发调试时，经常需要只测试其中的某个 stage，或者暂时跳过某些 stage，那么只需在 //*/ ----- Stage x ----- 与 /*/ ----- Stage x ----- 之间进行切换。 因此这种注释方法就能在尽可能减少对代码的破坏的同时，实现高效率的调试。\n总结 总结一下，本文介绍了一种 C/C++/C# 风格的注释方法\n1 2 3 4 5 6 7 //*/ 一行或多行激活的代码 int a = 0; //*/ /*/ 一行或多行被注释的代码 int b = 0; //*/ 这种注释方法有以下几个优点：\n只需少量操作就可以实现代码块的注释与取消注释 由于对注释的增删操作是在代码所在行之外进行的，所以不容易破坏代码块的内容 美观，可以在 //*/ 后书写额外的内容，方便对代码块进行标注 希望读者能够寻找到这种注释方法的更多应用场景，为自己的 C/C++/C# 学习和开发带来便利。\n","date":"2023-11-28T11:04:03+08:00","image":"https://maxwelljay256.github.io/posts/a-useful-code-annotation/screenshot_hud772a455f3914001bb0a74ec5ab155b8_15255_120x120_fill_box_smart1_3.png","permalink":"https://maxwelljay256.github.io/posts/a-useful-code-annotation/","title":"一种实用的 C/C++/C# 代码注释方法"},{"content":"2023 年 11 月 17 日，Maxwell Jay 的幻想乡正式建成。\n","date":"2023-11-17T16:22:12+08:00","permalink":"https://maxwelljay256.github.io/posts/hello-world/","title":"你好，世界！"}]