[{"content":"刚考完复变函数与积分变换，有一个星期可以喘息一下了。 我闲得没事干，就开始在 Microsoft Learn 上学习 C#。\n普通的注释方法怎么你了？ 和以前学习 C 和 C++ 一样，我又回到了那个照着例程抄写、反复调试运行的过程。 这里面将代码注释掉是一个常见的操作。 一般来说，我们要想注释一行 C 语言风格的代码（对 C/C++/C# 都适用），常用 //：\n1 // printf(\u0026#34;Hello, world!\\n\u0026#34;); 如果是一大段的代码，我们常用 /* */：\n1 2 3 4 5 6 7 /* int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } */ 但是这两种方法都有一定的不方便的地方。 首先，对于第一种注释方法，即使 VS Code 有 Ctrl+/ 快捷键，但是每一行都要加上 // 还是有点麻烦。 而且对于像我这种书写格式强迫症来说，当我看到以下第 2 行的注释时，我会忍不住给它加个空格变成第 1 行的样子：\n1 2 // printf(\u0026#34;Hello, world!\\n\u0026#34;); //printf(\u0026#34;Hello, world!\\n\u0026#34;); 其次，对于第二种注释方法，一旦在一个文件里用得太多了，往往会使代码变得非常难看。\n1 2 3 4 5 6 7 8 /* int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); return 0; } */ // ↑ 在一个 } 下面又是一个 */，让函数看上去非常不舒服 而且要想删掉这段注释，就必须既删掉这段注释的开头 /*，又要删掉注释的结尾 */，否则整个文件都会出问题，非常麻烦。\n一种实用的注释方法 这个时候我想起来了过去在 HITSZ-VEX 程序组培训时，Longbin 教给我们的一种注释方法。 它的内容是，在要注释的代码块开头和结尾都添加一行 //*/\n1 2 3 4 5 6 //*/ int a = 0; int b = 1; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, a + b); printf(\u0026#34;Hello, world!\\n\u0026#34;); //*/ 在这种情况下，代码仍是有效的。 如果想要注释掉这段代码，只需将第一个 //*/ 改为 /*/。\n1 2 3 4 5 6 /*/ \u0026lt;- 只删掉了一个 \u0026#39;/\u0026#39; int a = 0; int b = 1; printf(\u0026#34;%d + %d = %d\\n\u0026#34;, a, b, a + b); printf(\u0026#34;Hello, world!\\n\u0026#34;); //*/ 如果想要再次激活这段代码，那么把 /*/ 改回 //*/ 就行了。\n下面我来介绍一下这种注释方法的几个用处。\n有什么用呢？ 学习 C/C++/C# 时 初学一种编程语言时，我们往往会照着例程抄写，然后反复调试运行。\n例如我正在学习 C# 的逻辑运算，Microsoft Learn 上的培训给了若干示例代码。 我想把它们都记录下来，但测试运行效果时，我只想运行我最新抄写下来的那一段代码，因此我的文件看起来是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /*/ 相等运算符 Console.WriteLine(\u0026#34;a\u0026#34; == \u0026#34;a\u0026#34;); Console.WriteLine(\u0026#34;a\u0026#34; == \u0026#34;A\u0026#34;); Console.WriteLine(1 == 2); string myValue = \u0026#34;a\u0026#34;; Console.WriteLine(myValue == \u0026#34;a\u0026#34;); //*/ /*/ string value1 = \u0026#34; a\u0026#34;; string value2 = \u0026#34;A \u0026#34;; Console.WriteLine(value1.Trim().ToLower() == value2.Trim().ToLower()); //*/ /*/ 比较运算符 Console.WriteLine(1 \u0026gt; 2); Console.WriteLine(1 \u0026lt; 2); Console.WriteLine(1 \u0026gt;= 1); Console.WriteLine(1 \u0026lt;= 1); //*/ //*/ 返回布尔值的方法 string pangram = \u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;; Console.WriteLine(pangram.Contains(\u0026#34;fox\u0026#34;)); Console.WriteLine(pangram.Contains(\u0026#34;cow\u0026#34;)); //*/ 当我想要回头测试前面的代码块时，我只需修改两处地方，一个是把要激活的代码块的 /*/ 改为 //*/，另一个是把要禁用的代码块的 //*/ 改为 /*/。\n概括下来，只需一次删除操作和一次添加操作，就可以实现代码块的切换。\n读者可以设想或实验一下使用普通的注释方法 // 和 /* */，以上的内容要怎么写才能达到同样的效果、至少会使用到多少次删除和添加的操作。\n懂了吧？😏\n调试程序 无论是机器人制作还是嵌入式开发，我们往往会对一些顺序执行的流程进行调试。\n例如我曾经还在 HITSZ-VEX 的时候，我们的机器人自动程序大概是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void autonomous() { //* ----- Begin ----- SomeNamespace::SomeClass::SomeFunction(); SomeNamespace::SomeTask *task = new SomeNamespace::SomeTask(someParams); // Some other code //*/ //*/ ----- Stage 1 ----- function1(); ... //*/ //*/ ----- Stage 2 ----- function2(); ... //*/ //*/ ----- Stage 3 ----- funtion3(); ... //*/ //*/ ----- End ----- // 一组动作 delete task; } 我们在开发调试时，经常需要只测试其中的某个 stage，或者暂时跳过某些 stage，那么只需在 //*/ ----- Stage x ----- 与 /*/ ----- Stage x ----- 之间进行切换。 因此这种注释方法就能在尽可能减少对代码的破坏的同时，实现高效率的调试。\n总结 总结一下，本文介绍了一种 C/C++/C# 风格的注释方法\n1 2 3 4 5 6 7 //*/ 一行或多行激活的代码 int a = 0; //*/ /*/ 一行或多行被注释的代码 int b = 0; //*/ 这种注释方法有以下几个优点：\n只需少量操作就可以实现代码块的注释与取消注释 由于对注释的增删操作是在代码所在行之外进行的，所以不容易破坏代码块的内容 美观，可以在 //*/ 后书写额外的内容，方便对代码块进行标注 希望读者能够寻找到这种注释方法的更多应用场景，为自己的 C/C++/C# 学习和开发带来便利。\n","date":"2023-11-28T11:04:03+08:00","image":"https://maxwelljay256.github.io/posts/a-useful-code-annotation/screenshot_hud772a455f3914001bb0a74ec5ab155b8_15255_120x120_fill_box_smart1_3.png","permalink":"https://maxwelljay256.github.io/posts/a-useful-code-annotation/","title":"一种实用的 C/C++/C# 代码注释方法"},{"content":"最近在尝试使用 WSL 2 作为开发 ESP-32 的工具，但是 WSL 不像 VMWare 虚拟机那样可以直接访问硬件，而是一个纯虚拟环境，无法直接访问 USB 设备，所以需要一些额外的工具来实现 USB 设备的共享。\n参考资料：WSL/连接 USB 设备 - Microsoft Learn\n先决条件 Windows 11（内部版本 22000 或更高版本） 具有 x64/x86 处理器的计算机 Linux 发行版已安装并设置为 WSL 2（本次使用的是 Ubuntu 20.04 LTS） 安装 USPIPD-WIN 项目 方法 1：从 GitHub 下载安装 仓库链接：usbipd-win\n方法 2：使用 Windows 程序包管理器程序 (winget) 安装 打开 PowerShell 并运行以下命令：\n1 winget install --interactive --exact dorssel.usbipd-win 在 Linux 中安装 USBIP 工具和硬件数据库 在 Ubuntu 中，运行以下命令安装工具和硬件数据库：\n1 sudo apt install linux-tools-generic hwdata 每次要启动 USBIP 服务时，运行以下命令：\n1 sudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20 此时，一个服务就会在 Windows 上运行以共享 USB 设备，并且在 WSL 中安装了必要的工具来连接到共享设备。\n附加 USB 设备 通过管理员模式打开 PowerShell 并运行以下命令，列出所有连接到 Windows 的 USB 设备：\n1 usbipd wsl list 本次实验连接的是一个 ESP-32 Devkit-M，输出如下：\n这里面 Silicon Labs CP210x USB to UART Bridge (COM5) 就是我们想要连接的开发板了，2-1 就是它的设备总线 ID。\n选择要附加到 WSL 的设备总线 ID，然后运行以下命令：\n1 usbipd wsl attach --busid \u0026lt;bus_id\u0026gt; 其中 \u0026lt;bus_id\u0026gt; 是要附加的设备总线 ID，即步骤 1 中输出的“2-1”。 此时设备就会从 Windows 上断开连接，并且在 WSL 上显示为一个 USB 设备。\n在 Ubuntu 中，运行以下命令，列出所有连接到 WSL 的 USB 设备：\n1 lsusb 然后就成功显示到了开发板：\n测试连接以及断开连接 我提前在 WSL 上用 esp-idf 工具链编译了一个简单的 hello-world 程序，现在尝试用 esp-idf 工具链将 WSL 中的项目烧录到开发板上。\n通过 ls /dev/tty* 命令查找到开发板的串口设备为 /dev/ttyUSB0，所以可以运行以下命令烧录程序：\n1 idf.py -p /dev/ttyUSB0 flash 我也尝试了直接使用设备总线 ID 来烧录程序，但没有成功……\n1 idf.py -p /dev/bus/usb/002/001 flash 输出如下：\n1 2 3 4 5 6 esptool.py v3.3.4-dev Serial port /dev/bus/usb/002/001 Traceback (most recent call last): File \u0026#34;/home/jay/.espressif/python_env/idf4.4_py3.8_env/lib/python3.8/site-packages/serial/serialposix.py\u0026#34;, line 322, in open self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK) PermissionError: [Errno 13] Permission denied: \u0026#39;/dev/bus/usb/002/001\u0026#39; 嘛，不管那个了，运行串口监视器，可以看到开发板是正常运行的：\n1 idf.py -p /dev/ttyUSB0 monitor 使用结束后，其实可以直接将 USB 设备从电脑上拔出，或者在管理员模式下运行 PowerSheell 命令来断开连接：\n1 usbipd wsl detach --busid \u0026lt;busid\u0026gt; 实际操作下来，使用命令断开 WSL 的 USB 连接后，Windows 上的设备管理器中又显示出了设备。\n","date":"2023-11-24T20:56:12+08:00","image":"https://maxwelljay256.github.io/posts/wsl-connect-usb/ESP32-Devkit_hu053b9317d90769e57a9b8211317cf12c_1799982_120x120_fill_q75_box_smart1.jpg","permalink":"https://maxwelljay256.github.io/posts/wsl-connect-usb/","title":"将 USB 设备连接到 WSL"},{"content":"2023 年 11 月 17 日，Maxwell Jay 的幻想乡正式建成。\n","date":"2023-11-17T16:22:12+08:00","permalink":"https://maxwelljay256.github.io/posts/hello-world/","title":"你好，世界！"}]